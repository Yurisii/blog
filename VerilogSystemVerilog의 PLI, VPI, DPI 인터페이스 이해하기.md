## 서론: 하드웨어 설계 언어와 외부 언어의 연결고리

Verilog 및 SystemVerilog로 설계/검증을 하다 보면 **PLI**, **VPI**, **DPI**라는 용어를 접하게 됩니다. 이는 Verilog/SystemVerilog 시뮬레이터와 C/C++ 같은 **외부 언어를 연결하는 인터페이스**를 가리킵니다. 초심자 엔지니어(설계팀과 검증팀 모두)가 이해하기엔 다소 생소할 수 있지만, 개념을 알기 쉽게 풀어보겠습니다. 배경부터 **어떤 상황에서 사용하는지**, 그리고 **각 인터페이스의 차이점**을 살펴보면 이 글 하나로 *“PLI/VPI/DPI가 뭔지 이제 알겠다!”*는 느낌을 받을 수 있을 것입니다.

이하에서는 각 인터페이스를 순서대로 설명하며, 필요시 비교와 예시를 통해 개념을 자연스럽게 전달하겠습니다.

## PLI (Programming Language Interface) – Verilog의 프로그래밍 언어 인터페이스

### PLI란 무엇인가?

**PLI**는 _Programming Language Interface_의 약자입니다. 쉽게 말해, **Verilog 시뮬레이터와 함께 동작하는 C 코드를 연결하는 메커니즘**입니다. Verilog 자체만으로 부족한 기능이나 외부 프로그램과의 연동이 필요할 때, PLI를 통해 C로 작성된 코드를 Verilog 시뮬레이션에 삽입하거나 Verilog에서 호출할 수 있습니다. 초기 **PLI 1.0** 시절에는 시뮬레이터마다 구현이 제각각이어서 이식성이 떨어졌는데, 이후 표준화된 **PLI 2.0**이 등장하며 이러한 문제를 해결했습니다. (PLI 2.0을 바로 다음에 설명할 **VPI**라고 부릅니다.)

**배경:** Verilog가 상용화되던 1990년대에, 하드웨어 시뮬레이션 중 C 코드를 실행할 필요성이 대두되었습니다. 예를 들어 **Verilog에서 지원하지 않는 시스템 기능**을 구현하거나, **HW 동작을 소프트웨어적으로 모델링**하기 위한 요구가 있었습니다. 이를 위해 Verilog 표준에 PLI가 도입되었고, 사용자 정의 **시스템 함수/태스크($... 형태)**를 C로 구현하고 Verilog에서 호출하는 방식이 가능해졌습니다. PLI는 Verilog 시뮬레이터의 내부 자료구조에 접근할 수 있는 함수들의 집합으로, Verilog 동작을 훅(hook) 걸어 제어할 수 있는 **플러그인 API**라고 볼 수 있습니다.

### PLI의 활용 사례

- **사용자 정의 시스템 태스크 구현:** 예를 들어 `$display`나 `$finish` 같은 내장 시스템 태스크처럼, 사용자가 `$my_task`라는 새 태스크를 만들어 특정 동작을 수행하게 할 수 있습니다. C로 해당 기능을 구현하고 PLI를 통해 연결하면, Verilog 코드에서 `$my_task`를 호출하여 C 함수가 실행되도록 할 수 있습니다. 과거 검증 환경에서 임의의 디버그 출력이나 복잡한 수학 연산 등을 위해 이런 사용자 태스크를 만들곤 했습니다.
    
- **시뮬레이터 제어 및 모니터링:** PLI를 이용하면 시뮬레이션 시간 진행을 제어하거나, 신호 값이 변경되는 순간을 포착하는 등 **시뮬레이터의 이벤트에 콜백을 걸어 동작**시킬 수 있습니다. 예를 들어 특정 신호가 1->0으로 떨어질 때마다 C 함수가 호출되어 로그를 남기게 할 수 있습니다.
    
- **외부 환경 연동:** 설계된 하드웨어 모델을 외부 소프트웨어와 연계해 **코-시뮬레이션**할 때도 PLI를 사용했습니다. 예를 들어, Verilog 테스트벤치가 네트워크 소켓을 통해 다른 프로그램과 통신해야 한다면 PLI로 C 소켓 코드를 호출해 구현할 수 있습니다.
    
- **기타 활용:** 파일 입출력의 확장(Verilog 내장 파일 IO로 안 되는 특수한 포맷 처리), 대용량 메모리 모델링(C로 메모리 동작을 구현하고 Verilog에서 접근) 등도 PLI의 전통적인 활용 예입니다.
    

### 기술적 특징과 이해하기 쉽게 풀어본 비유

PLI를 기술적으로 보면, **시뮬레이터 내부를 들여다보고 조종할 수 있는 도구**입니다. C로 작성된 함수가 Verilog 시뮬레이터 엔진과 직접 상호작용하기 때문에, 마치 **시뮬레이터의 뚜껑을 열고 내부를 건드리는 느낌**입니다. PLI의 C 함수들은 `vpi_handle` 같은 **시뮬레이터 객체에 대한 핸들**을 통해 신호, 모듈, 변수 등에 접근하고 값을 읽거나 쓸 수 있습니다. 또한 `tf_`로 시작하는 함수들은 Verilog의 인자 값을 가져오거나 반환값을 지정하는 등의 역할을 합니다. 이러한 **TF(Task Function) 라이브러리와 ACC(Access) 라이브러리**가 PLI 1.0의 두 축이었는데, 이들을 잘 활용하면 시뮬레이션의 거의 모든 부분에 개입할 수 있었습니다.

하지만 이러한 강력함에는 복잡성도 따라옵니다. PLI를 쓰려면 C 언어뿐 아니라 **Verilog 시뮬레이터의 자료구조와 동작 시점**을 잘 이해해야 했습니다. 예를 들어, `$my_task`를 만들려면 해당 이름과 연동된 C 함수를 등록하고, 시뮬레이터가 해당 태스크를 인식하도록 초기화하는 과정 등이 필요했죠. 이를 비유하자면, **Verilog와 C가 대화하도록 통역사를 세우는데, 그 통역사가 시뮬레이터 내부 규칙도 다 알아야 하는 상황**입니다.

### PLI의 한계와 VPI로의 진화

PLI 1.0은 유용했지만 한계도 분명했습니다. 가장 큰 문제는 **시뮬레이터마다 구현이 조금씩 달랐다는 점**입니다. 표준이 미흡해 Cadence, Synopsys, Mentor 등 시뮬레이터 벤더마다 PLI 함수 지원이 달라 이식성이 떨어졌습니다. 또한 TF/ACC 함수들을 사용해 시스템 태스크를 정의하는 과정이 장황하고 실수하기 쉬웠습니다. 이러한 복잡성을 개선하기 위해 **IEEE 1364 표준(Verilog-2001)**에 **VPI(Verilog Procedural Interface)**가 도입되었고, 이를 흔히 _PLI 2.0_이라고 부릅니다. 2005년 이후의 Verilog 표준에서 **PLI 1.0은 VPI로 대체되면서 Deprecated(권장되지 않음)** 처리되었습니다. 즉, 최신 코드에서는 더 이상 옛 TF/ACC 함수를 사용하지 말라는 것이죠.

결론적으로, “PLI”라는 용어는 현재 두 가지 의미로 쓰입니다. **넓은 의미의 PLI**는 Verilog와 외부 언어 인터페이스를 총칭하며, **좁은 의미의 PLI**는 옛 TF/ACC 방식을 뜻합니다. 이후로는 주로 **표준화된 VPI**와 SystemVerilog의 **DPI**를 사용하게 됩니다. 다음 섹션에서 VPI를 살펴보겠습니다.

## VPI (Verilog Procedural Interface) – 표준화된 PLI 2.0

### VPI란 무엇인가?

**VPI**는 Verilog Procedural Interface의 약자로, 위에서 언급한 PLI 2.0에 해당합니다. **IEEE 1364 Verilog 표준에 포함된 공식 인터페이스**로, Verilog HDL과 C 언어를 연동하는 표준 C 함수들의 집합입니다. VPI를 통해 **Verilog의 동작을 C로 제어**하거나, **Verilog 코드에서 직접 C 함수를 호출**할 수 있습니다. VPI는 SystemVerilog에도 그대로 계승되었으며, 사실상 Verilog 계통에서 _유일하게 남은 저수준 프로그래밍 인터페이스_입니다.

VPI 이전의 PLI 1.0 (TF/ACC)은 표준이 모호하고 구현이 제각각이라 “한 번 작성하면 모든 시뮬레이터에서 동작한다”는 보장이 없었습니다. 반면 **VPI는 IEEE 표준이므로 대부분의 시뮬레이터에서 동일하게 동작**합니다. 그래서 _VPI 코드 한 번 잘 작성해두면 ModelSim, VCS, NC-Verilog 등 어디서나 돌릴 수 있다_는 장점이 있습니다.

### VPI로 무엇을 할 수 있나?

VPI가 제공하는 기능은 매우 강력하고 다양합니다. 주요 기능은 다음과 같습니다:

- **디자인 구조 탐색(Introspection):** VPI 함수를 사용하면 시뮬레이션 중 **전체 설계 계층구조를 탐색**할 수 있습니다. 예를 들어 최상위 모듈부터 하위 인스턴스, 신호선(net), 레지스터, 포트 등을 **손잡이(handle)**로 얻어와 그 이름이나 값을 읽는 식입니다. 이를 통해 _“설계 내에 있는 모든 레지스터 신호의 리스트 출력”_ 같은 작업을 C 코드로 구현할 수 있습니다.
    
- **이벤트 콜백 등록:** VPI는 **시뮬레이션 이벤트에 대한 콜백**을 지원합니다. 설계 신호 값이 변경되거나(`cbValueChange`), 시간 단계가 진행되거나(`cbNextSimTime` 등), 시뮬레이션 시작/종료 시(`cbStartOfSimulation`, `cbEndOfSimulation`) 등에 사용자가 등록한 C 함수가 자동으로 호출되도록 설정할 수 있습니다. 이를 활용하면 *“특정 신호가 변할 때마다 C 함수로 분석/로그 수행”*과 같은 동작이 가능합니다.
    
- **사용자 정의 시스템 태스크/함수:** VPI를 이용하면 Verilog에 새로운 `$system_task`나 기능 함수를 추가할 수 있습니다. Verilog 코드에서 `$my_analysis(data);`처럼 호출하면, 미리 VPI로 등록해둔 C 함수가 실행되어 인자 `data`를 받아 처리하도록 만들 수 있습니다. (사실 이러한 기능은 SystemVerilog DPI로도 일부 대체되었지만, VPI로도 구현 가능합니다.)
    

이처럼 VPI를 활용하면 **시뮬레이터의 동작을 속속들이 제어**할 수 있습니다. PLI 1.0 시대의 기능을 모두 포괄하면서도 일관된 함수 스타일을 제공하기 때문에, 배우기는 여전히 어렵지만 논리적 체계는 더 깔끔합니다.

### 실무 관점에서 VPI 활용 예시

- **신호 무결성 검사 도구:** 예를 들어 설계팀에서 *“모든 레지스터는 리셋 신호에 동기되어 0으로 초기화되어야 한다”*는 규칙을 검증한다고 합시다. 이때 VPI를 써서 시뮬레이션 시작 시(`StartOfSimulation` 콜백) **설계 내 모든 레지스터 신호를 순회**하면서 초기값을 검사하는 툴을 만들 수 있습니다. 이는 순수 Verilog만으로는 쉽지 않지만, VPI로 C에서 설계 구조를 읽어와 간단히 구현할 수 있습니다.
    
- **파형 로그 또는 커스텀 모니터링:** 시뮬레이터의 기본 `$dumpvars` 대신, 사용자 정의 형식으로 파형이나 이벤트를 기록하고 싶다면 VPI 콜백을 활용할 수 있습니다. 예를 들어 _모든 신호의 값 변화를 가로채어_ C 코드로 DB에 저장하거나, 특정 프로토콜 이벤트 발생 시 C 코드로 요약 출력하는 등이 가능합니다.
    
- **HW/SW 공동 시뮬레이션:** 검증팀에서 가끔 **소프트웨어 모델과 하드웨어를 함께 돌려야 하는 경우**가 있습니다. 예를 들어 Verilog CPU 모델이 명령을 실행하면 C로 작성된 주변장치 모델이 반응하게 만들 수 있습니다. VPI를 사용해 Verilog에서 C 함수(디바이스 모델 호출)를 부른다든지, 또는 C 쪽에서 주기적으로 VPI를 통해 Verilog 레지스터를 읽어간다든지 하는 식으로 **양방향 소통**을 구현할 수 있습니다.
    

위 사례들에서 볼 수 있듯, VPI는 주로 **검증 환경이나 시뮬레이터 확장 도구**를 만들 때 많이 쓰입니다. 설계팀보다는 검증/IP 개발팀에서 더 친숙한 기술이지만, 설계팀도 VPI로 제작된 툴이나 라이브러리를 접할 수 있습니다. 예를 들어 메모리 초기화 파일을 특수하게 파싱하는 툴이나, 설계 검증용 커버리지 수집 도구 등이 VPI로 구현되어 제공되기도 합니다.

비유를 해보면, VPI는 Verilog 시뮬레이터를 **“원격조종”**하는 리모컨 같습니다. C로 작성된 코드가 리모컨 신호를 보내 시뮬레이터 내부의 특정 기능을 발동시키는 것이죠. 이 리모컨(VPI API)을 잘 사용하면 시뮬레이션 세계를 마음대로 둘러보고 조작할 수 있지만, 리모컨의 많은 버튼들(수백 개의 VPI 함수들)을 익히고 정확히 눌러야 한다는 부담이 있습니다.

### VPI 사용 방법 (툴 관점)

실제로 VPI를 쓰려면 **시뮬레이터가 제공하는 VPI 헤더 파일**(`vpi_user.h` 등)을 포함하여 C 코드를 작성하고, 그 코드를 컴파일해 **공유 라이브러리(.so 또는 .dll)**를 생성해야 합니다. 이 라이브러리를 시뮬레이션 시에 로드하면, 시뮬레이터는 그 안에 등록된 함수들을 인지하고 Verilog와 연결합니다. 대부분의 시뮬레이터는 **커맨드라인 옵션이나 스크립트로 VPI 라이브러리 로드**를 지원합니다. 예를 들어 Cadence의 Incisive/Xcelium (ncverilog 계열)에서는 `-loadvpi ./myvpi.so:register_hello` 같은 옵션으로 VPI 코드를 로드할 수 있습니다. ModelSim/Questa 등의 툴도 비슷하게 플래그를 주어 PLI/VPI .dll을 로드하거나, 시뮬레이션 시작 시 Tcl 커맨드로 로드할 수 있습니다. 이렇게 하면 Verilog 코드에서 `$my_task` 호출 시 우리 C 함수가 동작하거나, 설계 내 이벤트 발생 시 C 콜백이 수행되는 환경이 갖춰집니다.

### VPI와 PLI의 관계, 그리고 한계

앞서 설명했듯, **VPI는 PLI 1.0을 대체한 표준 인터페이스**입니다. 현재 “PLI 프로그래밍을 했다”는 말은 대부분 VPI를 썼다는 의미로 통용될 정도로, 새로운 개발에서는 VPI 함수들을 사용합니다. VPI는 PLI 1.0의 복잡함을 상당 부분 줄였지만, **근본적인 철학은 PLI와 동일**합니다. 여전히 시뮬레이터의 내부 자료를 다루고 이벤트를 제어하는 저수준 API이고, 배우는 데 시간이 걸립니다.

또한 VPI로도 커버되지 않는 부분이 있거나, **더 쉬운 대안의 필요성**이 제기되었습니다. 이를테면 간단히 C 함수 하나 호출하는데도 VPI 초기화, 등록 과정이 필요하니 번거롭다는 의견이 많았습니다. 이런 배경에서 **SystemVerilog DPI**가 나오게 되는데, DPI는 VPI의 일부 기능을 **더 간결한 방법으로** 제공해줍니다. 다음으로 DPI에 대해 알아보겠습니다.

## DPI (Direct Programming Interface) – SystemVerilog의 다이렉트 인터페이스

### DPI란 무엇인가?

**DPI**는 _Direct Programming Interface_의 약자로, **SystemVerilog에 도입된 새로운 외부 언어 인터페이스**입니다. 간단히 말해, *“SystemVerilog 코드에서 C 함수를 직접 호출하거나, C 코드에서 SystemVerilog 함수를 직접 호출할 수 있게 해주는 기능”*입니다. DPI는 2000년대 중반 Accellera(SystemVerilog 표준화 기구)에 의해 표준으로 정의되었는데, 그 기원은 Synopsys사의 VCS 시뮬레이터의 **DirectC** 기술과 Co-Design사의 SystemSim 시뮬레이터의 **CBlend** 기술을 합쳐놓은 것입니다. 이렇게 태동한 DPI는 2005년 이후 **IEEE 1800 SystemVerilog 표준**에 포함되어, 현재 모든 주요 Verilog/SystemVerilog 시뮬레이터(VCS, ModelSim/Questa, Xcelium 등)에서 지원됩니다.

**DPI의 핵심 개념:** Verilog VPI처럼 복잡한 핸들, 콜백 등록 절차 없이 **그냥 함수 호출하듯이 C 코드를 사용**하는 것입니다. 예를 들어, SystemVerilog에서 다음과 같이 선언할 수 있습니다:

```systemverilog
// SystemVerilog 코드 예시 (DPI 선언)
import "DPI-C" function int add_two(int a, int b);
```

위 한 줄로 *“외부에 `add_two`라는 C 함수를 int형 인수 2개를 받아 int를 리턴하는 형태로 쓸 것이다”*라는 약속을 합니다. 그 다음, C 코드에 해당 함수를 구현하고 컴파일/링크만 하면, Verilog 코드에서 `result = add_two(5, 7);`처럼 **일반 함수를 호출하듯** 사용할 수 있습니다. 내부적으로는 시뮬레이터가 적절히 C 함수와 연결해주지만, 사용자 입장에서는 Verilog에서 C 함수를 직접 부른다는 점에서 **사용법이 매우 단순화**되었습니다. 마찬가지로, `export "DPI-C"` 키워드를 쓰면 SystemVerilog 함수를 C 쪽에서 호출 가능하도록 노출(export)할 수도 있습니다.

정리하면, DPI는 **“Verilog와 C 사이의 간편한 함수 호출 통로”**입니다. 별도의 PLI 라이브러리 작성이나 시뮬레이터 API 지식 없이, 양쪽 함수의 프로토타입만 맞춰주면 됩니다. 이는 **기존 PLI/VPI의 복잡한 과정**을 생략하게 해주므로, 새로운 엔지니어도 비교적 부담 없이 활용할 수 있는 장점이 있습니다.

### 언제, 어디에 DPI를 사용하나?

DPI는 주로 **다음과 같은 상황**에서 활용됩니다:

- **소프트웨어 라이브러리 재사용:** 검증팀에서는 C/C++로 작성된 참고모델(reference model)이나 알고리즘 라이브러리가 있는 경우가 많습니다. 이를 SystemVerilog 테스트벤치에서 활용하고 싶을 때, DPI로 함수를 import하여 바로 호출할 수 있습니다. 예를 들어 암호화 알고리즘 C 라이브러리를 가져와 SV에서 사용하거나, 복잡한 수학 함수(sin, cos 등)를 C의 표준 수학 라이브러리로부터 호출하는 것이 가능합니다.
    
- **시뮬레이션 성능 향상:** 많은 양의 연산을 SystemVerilog보다 **C에서 처리하는 편이 빠른 경우**가 있습니다. 예를 들어 수천 개의 요소를 정렬하거나 필터링하는 일을 테스트벤치에서 해야 한다면, SV의 for문보다 C의 함수를 호출해 처리하는 것이 유리할 수 있습니다. DPI를 통해 C로 구현된 효율적인 코드를 호출함으로써 시뮬레이션 속도를 높일 수 있습니다.
    
- **외부 자원과 연계:** DPI를 사용하면 OS 함수나 소켓 통신 등 **시스템 레벨 작업**도 쉽게 수행 가능합니다. SystemVerilog 자체로는 네트워크 통신이나 시스템 호출이 제한적이지만, C로 이러한 기능을 만들고 DPI로 연결하면 테스트벤치가 외부 세계와 상호작용할 수 있습니다. 예를 들어 DPI-C 함수를 통해 **파일 입출력, 디스크 데이터 로드, TCP/IP 소켓 전송** 등을 구현할 수 있습니다.
    
- **SystemVerilog 함수의 외부 사용:** 경우에 따라서는 반대로 SystemVerilog 쪽에 구현된 함수를 외부 프로그램(C/C++)에서 호출해야 할 때도 있습니다. DPI `export`를 사용하면 C 코드가 SV 함수/태스크를 마치 콜백처럼 호출할 수 있습니다. (예: 외부 C 테스트 스크립트가 SV 시뮬레이터 내부 함수들을 호출하여 HW 동작을 제어)
    

### DPI의 장점: 쉽고 효율적

DPI가 도입된 가장 큰 이유는 **사용의 간편함**입니다. PLI/VPI처럼 복잡한 초기화나 핸들 처리 없이, **함수 선언 한 줄로 끝**이기 때문입니다. 몇 가지 주요 장점을 요약하면:

- **학습 곡선이 낮다:** C 언어로 함수 작성법만 알면 되며, 굳이 Verilog PLI 라이브러리의 상세를 몰라도 됩니다. Doulos의 튜토리얼 문구대로 *“기존 C 코드를 재사용할 수 있고, Verilog PLI/VPI를 알 필요 없이도 동작시킬 수 있다”*는 것이 핵심입니다.
    
- **직관적인 함수 호출:** Verilog에서 C 함수를 호출할 때 **별도의 우회 경로 없이 직접 호출**합니다. PLI 방식처럼 시스템 태스크 이름을 등록하고, 인자 목록을 일일이 읽어오는 절차가 없습니다. 그냥 SV 코드에 함수 이름과 인자를 쓰면, 곧장 C 함수로 제어가 넘어갑니다.
    
- **양방향 호출 지원:** PLI/VPI에서는 C에서 Verilog 함수를 직접 부르는 게 불가능했지만, DPI에선 `export`를 통해 **C->SV 함수 호출**도 표준화되었습니다. 예를 들어 C 코드가 시뮬레이션 중에 `sv_printf("Hello")` 같은 SV 함수를 불러서, SV 쪽 동작을 유발할 수 있습니다. 이는 HW/SW 상호작용에 유용한 기능입니다.
    
- **강한 형 검증과 이식성:** DPI는 SV와 C 간 데이터 교환 규칙이 엄격히 정의되어 있습니다. SV쪽에서 작성한 함수 프로토타입에 따라 **시뮬레이터가 인자 타입을 체크**하고 맞지 않으면 오류를 냅니다. 또한 표준화된 ABI(Application Binary Interface)를 규정하여, 한 컴파일러/플랫폼에서 만든 DPI 라이브러리를 다른 플랫폼의 동일 ISA 시뮬레이터에서도 사용할 수 있게 설계되었습니다. (물론 OS나 컴파일러에 따라 재컴파일이 필요할 수는 있지만, 기본 원칙은 호환성을 높이자는 것입니다.)
    
- **일부 PLI 기능의 간소화:** DPI로 **대체 가능한 PLI/VPI 기능**들이 있습니다. 예를 들어 Verilog에서 C 함수 호출 및 값 반환 같은 동작은 이제 DPI 한 줄로 해결됩니다. 과거에는 `tf_getarg` 등 PLI 함수를 통해 인자를 받고 `tf_put`으로 값 돌려주는 식이었는데, DPI에서는 그냥 리턴값을 쓰면 되죠. 이처럼 *“PLI로 가능하지만 복잡했던 일의 상당수를 더 쉽게 할 수 있다”*는 것이 DPI의 매력입니다.
    

### DPI의 한계와 VPI와의 차이점

DPI가 만능은 아닙니다. **설계/검증 시나리오에 따라 DPI로 할 수 없는 일은 여전히 VPI를 사용해야 합니다.** 주요 차이점을 살펴보면:

- **시뮬레이터 제어 능력:** DPI는 **수동으로 호출될 때만 실행**됩니다. 즉, SystemVerilog 코드에서 함수를 부를 때에만 C 코드를 태워 실행하고 바로 복귀하죠. 반면 VPI는 **시뮬레이터 이벤트에 자동 연동**될 수 있습니다. 예를 들어 DPI-C 함수는 _자발적으로_ “신호 값 변경을 감지하여 동작”할 방법이 없습니다. 반드시 SV 코드가 그 변화를 감지해 DPI 함수를 호출해줘야 합니다. 하지만 VPI는 해당 신호에 콜백을 걸어두면 **시뮬레이터가 알아서 C 함수를 불러주는** 차이가 있습니다. 따라서 _“어떤 사건 발생 시 자동으로 동작”_ 같은 플로우는 VPI의 영역입니다.
    
- **미래 이벤트 스케줄링:** DPI는 **미래 시간에 값을 예약**하는 기능이 없습니다. 예를 들어 _100ns 후에 어떤 신호에 값을 써라_ 같은 일을 DPI 자체로는 못합니다. 그러나 VPI (또는 PLI)는 `vpi_put_value` 등의 함수로 _특정 시간에 값이 바뀌도록 스케줄_할 수 있습니다. 비유하자면, DPI는 눈앞의 일만 바로 할 수 있고 미래 예약은 SV쪽 로직으로 처리해야 합니다. VPI는 시뮬레이터에 “나중에 이거 해”라고 미리 일정을 넣어둘 수 있죠.
    
- **신호 강제(force) 및 이벤트 취소:** DPI는 **시뮬레이터의 기본 동작을 덮어쓰는 능력**이 없습니다. 예를 들어 어떤 신호를 강제로 1로 유지하도록 하거나, 예정된 이벤트를 취소하는 등의 행위는 DPI로 불가능합니다. VPI/PLI는 이러한 저수준 제어까지 지원합니다. (물론 이런 기능은 위험하기 때문에 아주 특수한 경우에만 쓰입니다.)
    
- **데이터 타입 및 인자 유연성:** DPI로 import되는 함수는 **정해진 기본형 데이터**만 인자로 사용할 수 있습니다 (int, real, byte, string 등 SV와 호환 가능한 타입). 반면 VPI의 시스템 태스크는 인자로 **어떠한 종류의 표현식이나 데이터도** 넘길 수 있습니다. 예를 들어 VPI 기반 태스크는 _신호 이름, 계층 경로, 정수, 문자열, 연결(concatenation) 등_ 다양한 형태로 인자를 받을 수 있지만, DPI 함수는 그런 복잡한 인자를 직접 받지 못합니다. 또한 DPI 함수는 **인자 개수가 고정**되어 있어야 하며, 호출할 때 반드시 그 개수만큼 전달해야 합니다. VPI 태스크는 가변 개수의 인자도 처리할 수 있죠 (예: `$display`처럼 호출할 때마다 인자 수가 달라도 됨). 이처럼 **DPI는 단순한 함수 규격만 허용**하고, VPI는 Verilog 언어처럼 유연한 호출을 지원합니다.
    
- **시뮬레이터 데이터 구조 접근:** DPI에서는 **설계 내부의 객체(신호, 모듈 등)에 직접 접근**할 방법이 없습니다. C 함수는 넘겨받은 인자 외에는 Verilog 세계를 모릅니다. (물론 고급 기법으로 DPI C 코드 안에서 다시 VPI 함수를 호출해 강제로 접근하는 꼼수는 있지만, 결국 VPI를 섞어 쓰는 것입니다.) 반면 VPI는 본래 목적이 **시뮬레이션 데이터 구조 분석**이므로, 설계의 모든 부분을 들여다볼 수 있습니다.
    
- **성능 및 기타:** 일반적으로 DPI 호출은 **오버헤드가 적고 빠르다**고 알려져 있습니다. 이유는 VPI 호출은 일단 Verilog 쪽에서 시스템 태스크 호출 -> 시뮬레이터가 인자 패킹 -> C calltf 함수 진입 -> 내부에서 값 언패킹 이런 다단계를 거치지만, DPI는 단순 함수 점프처럼 동작하기 때문입니다. 또한 DPI는 2계층 구조(SV 레이어 – C 레이어)로 설계되어 simulator와 foreign language가 명확히 분리되므로 **호환성과 효율성**이 높다고 합니다. 다만, DPI도 부적절하게 사용할 경우 성능 저하가 생길 수 있으므로 (예: 매우 자주 호출되는데 C 코드가 느린 경우 등) 적절한 상황에서 사용하는 것이 좋습니다.
    

위와 같은 이유로, **“모든 것을 DPI로 대체할 수는 없다”**는 것이 업계의 중론입니다. 하지만 다행히도 **대부분의 일반적인 용도에서는 DPI만으로 충분**합니다. VPI가 진가를 발휘하는 건 **특별히 시뮬레이터 구동을 조작해야 하는 경우**인데, 그런 경우가 아니라면 굳이 복잡한 VPI를 쓰지 않고 DPI로 빠르게 구현하는 편이 선호됩니다. 한 업계 전문가의 조언을 빌리자면: _“C/C++과 연동해서 뭔가 하려는데 DPI로 될 것 같으면 무조건 DPI부터 써라. DPI로 안 되는 일만 VPI로 해라”_는 것입니다. 그만큼 DPI가 실무에서 더 빈번하고 중요하게 쓰인다는 뜻입니다.

### DPI 사용 방법 (툴 관점)

DPI는 사용법이 비교적 간단하지만, 그래도 **시뮬레이터와 C 컴파일 설정**은 필요합니다. 일반적인 흐름은 다음과 같습니다:

1. **SV 측 선언:** SystemVerilog 코드에 `import "DPI-C"` 문으로 C 함수의 프로토타입을 선언합니다. 또한 C에서 SV 함수를 부르게 할 경우 `export "DPI-C"`로 내보낼 함수를 지정합니다. 시뮬레이터는 이 정보를 이용해 SV와 C를 연결합니다.
    
2. **C 측 구현:** 해당 C 함수를 실제로 작성합니다. 함수 이름과 인자 타입 등은 SV쪽 선언과 정확히 일치해야 합니다. C++의 경우 `extern "C"`로 선언하여 이름 충돌(name mangling)을 피합니다.
    
3. **컴파일 및 링크:** 시뮬레이터에 C 코드를 전달하는 방식은 툴마다 약간 다릅니다. 일부 툴(예: Mentor QuestaSim)은 `vlog` 컴파일 시 C 소스 파일을 함께 지정하면 **자동으로 컴파일 및 링크**해주기도 합니다. 그렇지 않은 경우, 수동으로 C 코드를 컴파일하여 `.so`/`.dll`를 만들고, 시뮬레이션 실행 시 `-sv_lib` 옵션 등으로 해당 라이브러리를 지정합니다. 예를 들어 ModelSim에서는 `vsim -sv_lib mylib` 형태로 DPI 공유 라이브러리를 로드할 수 있습니다. Synopsys VCS의 경우도 `vcs` 컴파일 단계에서 `-CFLAGS`나 `-LD` 옵션 등으로 C 오브젝트를 링크하거나, `dpiimport.cc` 방식 등을 지원합니다. Cadence Xcelium도 `-sv_lib` (혹은 과거 ncverilog의 `-loadvpi`, DPI도 여기에 포함) 옵션을 사용합니다.
    
4. **실행:** 설정이 맞게 되면, 시뮬레이션 중 SV 코드가 `import`된 함수를 호출할 때 해당 C 구현이 실행되고 값을 반환합니다. 특별히 VPI처럼 별도 초기화 코드를 짤 필요는 없지만, C 쪽에서 내부적으로 static 변수 관리나 메모리 할당이 필요하면 그 부분은 신경써야 합니다. (Questa 등 몇몇 시뮬레이터는 DPI C 코드에서 메모리 할당시 자체 allocator 사용을 권장하기도 합니다. 그러나 이것은 심화 내용이니 초심자 단계에서는 크게 걱정하지 않아도 됩니다.)
    

정리하면, **DPI는 툴 사용 관점에서도 훨씬 수월**합니다. PLI/VPI는 시뮬레이터별 옵션을 찾아 적용하고, PLI 부트스트랩 코드를 작성해야 했던 반면, DPI는 표준화된 방법으로 대부분 자동 처리됩니다. 이 역시 **생산성 향상** 측면에서 DPI가 환영받는 이유입니다.

## PLI, VPI, DPI 비교 요약

마지막으로 세 인터페이스를 한 눈에 비교해보겠습니다:

- **등장 시기/표준화:** PLI 1.0은 Verilog 초기부터 존재했지만 비표준적이었고, **VPI(PLI 2.0)**가 2001년 Verilog-IEEE 표준에 도입되어 2005년 판부터 **공식 표준**으로 자리잡았습니다. **DPI**는 SystemVerilog (IEEE 1800)에 의해 2005년경 등장하여 **현대적 표준 인터페이스**가 되었습니다.
    
- **주 목적:** PLI/VPI는 **시뮬레이터의 내부 데이터 접근 및 제어**입니다. 설계 구조 순회, 이벤트 콜백, 사용자 태스크 등 **시뮬레이터 플러그인 역할**을 합니다. DPI는 **외부 라이브러리와의 손쉬운 함수 연동**으로, 주로 **모델링/연산을 위임하거나 외부 프로그램과 통신**하기 위함입니다.
    
- **사용 난이도:** PLI (특히 1.0 TF/ACC)는 매우 난이도가 높았고, VPI도 함수를 수십 개 이상 익혀야 하는 등 어렵습니다. DPI는 비교적 쉽고, SystemVerilog 언어의 일부분처럼 느껴집니다.
    
- **기능상의 한계:** VPI는 시뮬레이터의 거의 모든 것을 할 수 있지만, **복잡성의 대가**를 치릅니다. DPI는 쉬운 대신 **제약**이 있습니다. 콜백이나 미래예약, 강제 등은 불가하고, 오로지 **함수 호출형 태스크**만 가능합니다. 대신 이 범위 내에서는 VPI보다 사용이 간단하고 성능도 좋습니다.
    
- **실행 및 성능:** VPI/PLI 기반 코드는 시뮬레이터와 깊숙히 연동되므로 잘못 작성하면 시뮬레이터 크래시까지 일으킬 수 있지만, 강력한 일들을 수행할 수 있습니다. DPI 코드는 비교적 분리되어 동작하므로 시뮬레이터를 _크게 흔들지 않고_ 필요한 작업만 합니다. 일반적으로 DPI 호출이 VPI 호출보다 **오버헤드가 낮고** 속도가 빠른 것으로 알려져 있습니다.
    
- **현업 권장 사항:** 새로운 기능을 구현해야 할 때, **가능하면 DPI를 사용**하는 것이 1순위이고, DPI로 할 수 없는 경우에만 VPI를 고려합니다. PLI 1.0 (TF/ACC)은 이미 오래 전에 사용 자제가 권고되어 사실상 **역사적 개념**으로만 알고 있으면 됩니다. 다만 기존에 작성된 PLI 1.0 코드가 남아있을 수 있어 문맥상 “PLI”라는 용어로 불릴 때 그 배경을 이해하는 정도면 충분합니다.
    

## 결론: 한눈에 정리하는 핵심 메시지

- **PLI**: Verilog의 옛 **프로그래밍 인터페이스**로, C 코드로 Verilog 시뮬레이션을 확장하는 개념입니다. 복잡하고 시뮬레이터마다 달랐던 **초창기 방법**이며, 현재는 역사적인 용어로 남았습니다.
    
- **VPI**: **표준화된 PLI 2.0**으로 불리며, Verilog/SystemVerilog에서 **공식 지원되는 C 인터페이스**입니다. **디자인 구조 탐색, 이벤트 콜백, 사용자 함수 구현 등** 강력한 기능을 제공합니다. 배우기는 어렵지만, 제대로 활용하면 시뮬레이션을 강력하게 통제할 수 있습니다.
    
- **DPI**: SystemVerilog의 **다이렉트 프로그래밍 인터페이스**로, **SV와 C 간 함수 호출을 쉽게 연결**해 줍니다. **재사용하고픈 C/C++코드가 있을 때 가장 먼저 고려되는 방법**이며, 실무에서 흔히 쓰입니다. VPI 대비 배우기 쉽고 일반적인 작업에 충분한 기능을 제공합니다. 다만 **콜백이나 시뮬레이터 제어 같은 고급 기능은 불가능**하므로, 그럴 땐 여전히 VPI를 사용해야 합니다.
    

마지막 팁으로, **설계팀**이라면 DPI를 통해 검증팀의 C 모델을 활용하거나, 복잡한 연산을 C에 맡겨 시뮬레이션을 가속하는 방향으로 주로 만나게 될 것입니다. **검증팀**이라면 VPI를 이용한 특수한 검증 툴이나 monitor를 작성하거나, 때로는 DPI로 외부 환경과 연동하는 작업을 많이 하게 될 것입니다. 이 글에서 다룬 개념들을 바탕으로, 문서를 하나 읽은 것만으로도 PLI/VPI/DPI가 무엇이고 언제 어떤 것을 쓰는지 감 잡으셨길 바랍니다. 필요할 때 이들을 활용하면 Verilog/SystemVerilog 시뮬레이션의 한계를 뛰어넘어 보다 유연하고 강력한 검증 환경을 구축할 수 있을 것입니다.