# TASK 2 ë°œí‘œ ì¤€ë¹„ ìë£Œ: ìœ„ìƒ ì •ë ¬ ë° ê·¸ë˜í”„ í‘œí˜„ (9.2 ~ 9.3)

**í•™ìŠµ êµì¬**: *Data Structures and Algorithm Analysis in C++ (4íŒ)*
**ë²”ìœ„**: Chapter 9.2 ~ 9.3
**ë°œí‘œ ëª©ì **: ìœ„ìƒ ì •ë ¬ì„ ì¤‘ì‹¬ìœ¼ë¡œ ê·¸ë˜í”„ í‘œí˜„, ì‚¬ì´í´ ê²€ì¶œ, ìµœë‹¨ ê²½ë¡œ íƒìƒ‰ê¹Œì§€ êµ¬í˜„ê³¼ í•¨ê»˜ ì„¤ëª…

---

## ìœ„ìƒ ì •ë ¬ (9.2)
### ìœ„ìƒ ì •ë ¬ (Simple Indegree-based algorithm)

```cpp
void Graph::topsort() {
    for (int counter = 0; counter < NUM_VERTICES; counter++) {
        Vertex v = findNewVertexOfIndegreeZero();
        if (v == NOT_A_VERTEX) {
            throw CycleFoundException();
        }
        v.topNum = counter;
        for (auto w : v.adj) {
            w.indegree--;
        }
    }
}
```

---

### Kahn's Algorithm (BFS ê¸°ë°˜)

**í•µì‹¬ ì•„ì´ë””ì–´**:
- ì§„ì… ì°¨ìˆ˜ê°€ 0ì¸ ì •ì ì„ íì— ì‚½ì…
- ì—°ê²°ëœ ê°„ì„  ì œê±°í•˜ë©´ì„œ ìƒˆë¡­ê²Œ ì§„ì… ì°¨ìˆ˜ê°€ 0ì¸ ì •ì ì„ ì‚½ì…

```cpp
vector<int> kahnTopologicalSort(int V, vector<vector<int>>& adj) {
    vector<int> in_degree(V, 0);
    for (int u = 0; u < V; ++u)
        for (int v : adj[u]) in_degree[v]++;

    queue<int> q;
    for (int i = 0; i < V; ++i)
        if (in_degree[i] == 0) q.push(i);

    vector<int> result;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        result.push_back(u);
        for (int v : adj[u])
            if (--in_degree[v] == 0)
                q.push(v);
    }
    return result;
}
```

**ì‚¬ì´í´ ê°ì§€**:
- ìœ„ìƒ ì •ë ¬ ê²°ê³¼ í¬ê¸° < V â†’ ì‚¬ì´í´ ì¡´ì¬

---

## ë¹„ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ì˜ ìµœë‹¨ ê²½ë¡œ (9.3)
### BFS ê¸°ë°˜ ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ (Figure 9.18)

**ìƒí™©**: ëª¨ë“  ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ 1ì¼ ë•Œ â†’ Dijkstra ëŒ€ì‹  BFS ì‚¬ìš©

**êµì¬ ì½”ë“œ (Figure 9.18)**:
```cpp
void Graph::unweighted( Vertex s )
{
    Queue<Vertex> q;

    for each Vertex v
        v.dist = INFINITY;

    s.dist = 0;
    q.enqueue( s );

    while( !q.isEmpty( ) )
    {
        Vertex v = q.dequeue( );

        for each Vertex w adjacent to v
            if( w.dist == INFINITY )
            {
                w.dist = v.dist + 1;
                w.path = v;
                q.enqueue( w );
            }
    }
}
```

**ì‘ìš© ì˜ˆì‹œ**:
- ë¯¸ë¡œ íƒìƒ‰
- ë‹¨ìˆœí•œ ë„ë¡œë§ì—ì„œ ìµœì†Œ ê±°ë¦¬ ì¸¡ì •

---

## ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ì˜ ìµœë‹¨ ê²½ë¡œ - Dijkstra ì•Œê³ ë¦¬ì¦˜ (9.3.2)
### ìš°ì„ ìˆœìœ„ í ê¸°ë°˜ Dijkstra ì•Œê³ ë¦¬ì¦˜

**ìƒí™©**: ìŒìˆ˜ê°€ ì•„ë‹Œ ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§„ ê·¸ë˜í”„ì—ì„œ ë‹¨ì¼ ì‹œì‘ì ìœ¼ë¡œë¶€í„° ëª¨ë“  ë‹¤ë¥¸ ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œ íƒìƒ‰

**í•µì‹¬ ì•„ì´ë””ì–´**:
- ì‹œì‘ ì •ì ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬ë¥¼ ì €ì¥í•˜ê³ , ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ì •ì  ì¤‘ ê°€ì¥ ê±°ë¦¬ê°€ ì§§ì€ ì •ì ì„ ìš°ì„ ìˆœìœ„ íë¥¼ ì´ìš©í•´ ì„ íƒ
- ì„ íƒëœ ì •ì ê³¼ ì—°ê²°ëœ ì •ì ë“¤ì˜ ê±°ë¦¬ë¥¼ ê°±ì‹ 

**êµì¬ ì½”ë“œ (Figure 9.31)**:
```cpp
void Graph::dijkstra( Vertex s )
{
    for each Vertex v
    {
        v.dist = INFINITY;
        v.known = false;
    }

    s.dist = 0;

    while( there is an unknown distance vertex )
    {
        Vertex v = smallest unknown distance vertex;

        v.known = true;

        for each Vertex w adjacent to v
            if( !w.known )
            {
                DistType cvw = cost of edge from v to w;

                if( v.dist + cvw < w.dist )
                {
                    // Update w
                    decrease( w.dist to v.dist + cvw );
                    w.path = v;
                }
            }
    }
}
```

**í•„ìš” ë°ì´í„° êµ¬ì¡° (Vertex - Figure 9.29 ìŠ¤ì¼€ì¹˜)**:
```cpp
/* PSEUDOCODE sketch of the Vertex structure.
 * In real C++, path would be of type Vertex *,
 * and many of the code fragments that we describe
 * require either a dereferencing * or use the
 * -> operator instead of the . operator.
 * Needless to say, this obscures the basic algorithmic ideas.
 */
struct Vertex
{
    List  adj;      // Adjacency list
    bool  known;    // Visited flag
    DistType dist;  // Distance from start node (e.g., int)
    Vertex path;    // Previous vertex on shortest path (e.g., Vertex*)
    // Other data and member functions as needed
};
```

**ìµœë‹¨ ê²½ë¡œ ì¶œë ¥ ì˜ˆì‹œ (Figure 9.30)**:
```cpp
/* Print shortest path to v after dijkstra has run.
 * Assume that the path exists.
 */
void Graph::printPath( Vertex v )
{
    if( v.path != NOT_A_VERTEX )
    {
        printPath( v.path );
        cout << " to ";
    }
    cout << v;
}
```

**ì‹œê°„ ë³µì¡ë„**: O(E log V) (ì´ì§„ í™ ìš°ì„ ìˆœìœ„ í ì‚¬ìš© ì‹œ)

**ì£¼ì˜**: ìŒìˆ˜ ê°€ì¤‘ì¹˜ ê°„ì„ ì´ í¬í•¨ëœ ê²½ìš° ì •í™•í•œ ê²°ê³¼ë¥¼ ë³´ì¥í•˜ì§€ ì•ŠìŒ (Bellman-Ford ì•Œê³ ë¦¬ì¦˜ í•„ìš”)
<!-- ... existing content up to the end of Section 4 (Dijkstra) ... -->

### ìŒìˆ˜ ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ì˜ ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ (Figure 9.32)

**ìƒí™©**: ìŒìˆ˜ ê°€ì¤‘ì¹˜ ê°„ì„ ì´ í¬í•¨ë  ìˆ˜ ìˆëŠ” ê·¸ë˜í”„ì—ì„œ ë‹¨ì¼ ì‹œì‘ì ìœ¼ë¡œë¶€í„°ì˜ ìµœë‹¨ ê²½ë¡œ íƒìƒ‰ (ìŒìˆ˜ ì‚¬ì´í´ì€ ì—†ë‹¤ê³  ê°€ì •)

**êµì¬ ì˜ì‚¬ ì½”ë“œ (Figure 9.32)**:
```cpp
void Graph::weightedNegative( Vertex s )
{
    Queue<Vertex> q;

    for each Vertex v
        v.dist = INFINITY;

    s.dist = 0;
    q.enqueue( s );

    while( !q.isEmpty( ) )
    {
        Vertex v = q.dequeue( );

        for each Vertex w adjacent to v
            if( v.dist + cvw < w.dist )
            {
                // Update w
                w.dist = v.dist + cvw;
                w.path = v;
                if( w is not already in q )
                    q.enqueue( w );
            }
    }
}
```

**ë‚´ìš© ìš”ì•½**:
ì´ ì½”ë“œëŠ” **ìŒìˆ˜ ê°€ì¤‘ì¹˜ ê°„ì„ **ì„ í¬í•¨í•˜ëŠ” ê·¸ë˜í”„ì—ì„œ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ì˜ í•œ ê°€ì§€ ë²„ì „ì…ë‹ˆë‹¤. ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ê³¼ ë‹¬ë¦¬ íë¥¼ ì‚¬ìš©í•˜ë©°, ê²½ë¡œê°€ ê°±ì‹ ëœ ì •ì ì´ íì— ì—†ìœ¼ë©´ ë‹¤ì‹œ ì¶”ê°€í•˜ì—¬ ìŒìˆ˜ ê°€ì¤‘ì¹˜ë¡œ ì¸í•´ ë°œìƒí•  ìˆ˜ ìˆëŠ” ìµœë‹¨ ê±°ë¦¬ì˜ ì¬ê°±ì‹ ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤. ì´ëŠ” SPFA(Shortest Path Faster Algorithm)ì™€ ìœ ì‚¬í•œ ë°©ì‹ì…ë‹ˆë‹¤.

---

## ìµœë‹¨ ê²½ë¡œ ì‘ìš©: ë‹¨ì–´ ì‚¬ë‹¤ë¦¬ (Figure 9.38)

**ìƒí™©**: í•œ ë‹¨ì–´ì—ì„œ ë‹¤ë¥¸ ë‹¨ì–´ë¡œ í•œ ê¸€ìì”© ë°”ê¿”ê°€ëŠ” ê³¼ì •(ë‹¨ì–´ ì‚¬ë‹¤ë¦¬)ì˜ ìµœë‹¨ ê²½ë¡œ(ìµœì†Œ ë³€ê²½ íšŸìˆ˜) íƒìƒ‰

**êµì¬ C++ ì½”ë“œ (Figure 9.38)**:
```cpp
// Runs the shortest path calculation from the adjacency map, returning a vector
// that contains the sequence of word changes to get from first to second.
vector<string> findChain (const unordered_map<string,vector<string>> & adjacentWords,
                          const string & first, const string & second )
{
    unordered_map<string,string> previousWord ;
    queue<string> q;

    q.push( first );

    while( !q.empty() )
    {
        string current = q.front(); q.pop();

        auto itr = adjacentWords.find( current );
        const vector<string> & adj = itr->second;

        for( string & str : adj )
        {
            if( previousWord[ str ] == "" )
            {
                previousWord[ str ] = current;
                q.push( str );
            }
        }
    }

    previousWord[ first ] = "";

    return getChainFromPreviousMap( previousWord, second, first );
}

// After the shortest path calculation has run, computes the vector that
// contains the sequence of word changes to get from first to second.
vector<string> getChainFromPreviousMap( const unordered_map<string,string> & previous,
                                        const string & second, const string & first )
{
    vector<string> result;
    const unordered_map<string,string> & prev = previous ; // const_cast equivalent

    for( string current = second; current != ""; current = prev.at( current ) )
    {
        result.push_back( current );
    }

    reverse( begin( result ), end( result ) );

    return result;
}
```

**ë‚´ìš© ìš”ì•½**:
ì´ ì½”ë“œëŠ” ì£¼ì–´ì§„ ë‘ ë‹¨ì–´ ì‚¬ì´ì˜ ìµœë‹¨ "ë‹¨ì–´ ì‚¬ë‹¤ë¦¬"ë¥¼ ì°¾ëŠ” C++ êµ¬í˜„ì…ë‹ˆë‹¤.
- `findChain` í•¨ìˆ˜ëŠ” **BFS(ë„ˆë¹„ ìš°ì„  íƒìƒ‰)**ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‹œì‘ ë‹¨ì–´(`first`)ì—ì„œ ëª©í‘œ ë‹¨ì–´(`second`)ê¹Œì§€ í•œ ê¸€ì ì°¨ì´ ë‚˜ëŠ” ë‹¨ì–´ë“¤ì„ ë”°ë¼ê°€ë©° ìµœë‹¨ ê²½ë¡œë¥¼ íƒìƒ‰í•˜ê³ , ê° ë‹¨ì–´ì— ë„ë‹¬í•˜ê¸° ì§ì „ì˜ ë‹¨ì–´ë¥¼ `previousWord` ë§µì— ê¸°ë¡í•©ë‹ˆë‹¤.
- `getChainFromPreviousMap` í•¨ìˆ˜ëŠ” `findChain`ì—ì„œ ì–»ì€ `previousWord` ë§µì„ ì‚¬ìš©í•˜ì—¬ ëª©í‘œ ë‹¨ì–´(`second`)ë¶€í„° ì‹œì‘ ë‹¨ì–´(`first`)ê¹Œì§€ ì—­ìœ¼ë¡œ ì¶”ì í•˜ì—¬ ì‹¤ì œ ë‹¨ì–´ ì‚¬ë‹¤ë¦¬ ê²½ë¡œë¥¼ êµ¬ì„±í•˜ê³  ì˜¬ë°”ë¥¸ ìˆœì„œë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
ì´ëŠ” ê·¸ë˜í”„(ë‹¨ì–´ê°€ ì •ì , í•œ ê¸€ì ì°¨ì´ ë‚˜ëŠ” ë‹¨ì–´ ê°„ì˜ ì—°ê²°ì´ ê°„ì„ )ì—ì„œ BFSë¥¼ í†µí•´ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ëŠ” ì‘ìš© ì˜ˆì‹œì…ë‹ˆë‹¤.

#### 9.38 ì½”ë“œ ì„¤ëª…
 **ëª©ì **: ì£¼ì–´ì§„ ë‹¨ì–´ ê·¸ë˜í”„ì—ì„œ first ë‹¨ì–´ë¶€í„° second ë‹¨ì–´ê¹Œì§€ ìµœë‹¨ ê²½ë¡œ (word ladder)ë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜

 **1. findChain() í•¨ìˆ˜**: BFSë¡œ ê²½ë¡œ íƒìƒ‰
```cpp
unordered_map<string, string> findChain(
    const unordered_map<string, vector<string>>& adjacentWords,
    const string& first,
    const string& second )
```
**í•¨ìˆ˜ ì„¤ëª…**: ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ `adjacentWords`ë¥¼ ë°›ì•„ì„œ `first` â†’ `second`ë¡œ ê°€ëŠ” ìµœë‹¨ ê²½ë¡œì˜ ì´ì „ ë‹¨ì–´ë“¤ì„ ê¸°ë¡í•œ mapì„ ë°˜í™˜

**ë‚´ë¶€ ë™ì‘**:
```cpp
unordered_map<string, string> previousWord;
queue<string> q;
```
- `previousWord`: ê° ë‹¨ì–´ê°€ ì–´ë–¤ ë‹¨ì–´ë¥¼ í†µí•´ ë„ë‹¬ë˜ì—ˆëŠ”ì§€ ì €ì¥
- `q`: BFSë¥¼ ìœ„í•œ í

```cpp
q.push(first); 
```
- ì‹œì‘ ë‹¨ì–´ `first`ë¥¼ íì— ì‚½ì… â†’ BFS ì‹œì‘

```cpp
while (!q.empty())
```
- íê°€ ë¹Œ ë•Œê¹Œì§€ BFS ë°˜ë³µ

```cpp
string current = q.front(); q.pop();
auto itr = adjacentWords.find(current);
```
- í˜„ì¬ ë‹¨ì–´ë¥¼ êº¼ë‚´ì„œ í•´ë‹¹ ë‹¨ì–´ì˜ ì´ì›ƒ ë‹¨ì–´ ëª©ë¡ì„ ê°€ì ¸ì˜´

```cpp
for (string& str : adj)
```
- ì¸ì ‘í•œ ë‹¨ì–´ë“¤ì„ ìˆœíšŒí•˜ë©´ì„œ

```cpp
if (previousWord[str] == "")
```
- ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë‹¨ì–´ë¼ë©´ (ì´ì „ ê²½ë¡œ ì •ë³´ê°€ ì—†ìŒ)

```cpp
previousWord[str] = current;
q.push(str);
```
- `current`ë¥¼ í†µí•´ ì²˜ìŒ `str`ì— ë„ë‹¬í–ˆìŒì„ ê¸°ë¡í•˜ê³  `str`ì„ íì— ì‚½ì…í•˜ì—¬ ë‹¤ìŒ ë‹¨ê³„ë¡œ íƒìƒ‰

```cpp
previousWord[first] = "";
```
- ë§ˆì§€ë§‰ì— ì‹œì‘ ë‹¨ì–´ `first`ì˜ ì´ì „ ê²½ë¡œëŠ” ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ""ë¡œ ì„¤ì •

- ê²½ë¡œ ì •ë³´ê°€ ì €ì¥ëœ mapì„ ë°˜í™˜

ğŸ”¹ **2. getChainFromPreviousMap() í•¨ìˆ˜**: ê²½ë¡œ ë³µì›
```cpp
vector<string> getChainFromPreviousMap(
    const unordered_map<string, string>& previous,
    const string& second )
```
**í•¨ìˆ˜ ì„¤ëª…**: `second` ë‹¨ì–´ë¶€í„° ê±°ìŠ¬ëŸ¬ ì˜¬ë¼ê°€ë©´ì„œ `first`ê¹Œì§€ì˜ ê²½ë¡œë¥¼ ë§Œë“¤ì–´ì„œ vectorë¡œ ë°˜í™˜

ğŸ”¸ **ë‚´ë¶€ ë™ì‘**:
```cpp
vector<string> result;
auto& prev = const_cast<unordered_map<string, string>&>(previous);
```
- `result`: ìµœì¢… ë‹¨ì–´ ê²½ë¡œ ì €ì¥ìš©
- `const_cast`ëŠ” operator[] ì‚¬ìš©ì„ ìœ„í•´ const ì œê±°

```cpp
for (string current = second; current != ""; current = prev[current])
    result.push_back(current);
```
- `second`ë¶€í„° ì‹œì‘í•´ì„œ, `prev` mapì„ ë”°ë¼ ê±°ìŠ¬ëŸ¬ ì˜¬ë¼ê°€ë©° ê²½ë¡œë¥¼ ì €ì¥

```cpp
reverse(begin(result), end(result));
```
- ê²½ë¡œê°€ ê±°ê¾¸ë¡œ ì €ì¥ë˜ì—ˆìœ¼ë¯€ë¡œ reverseë¡œ ìˆœì„œ ì •ë¦¬

- ì™„ì„±ëœ word ladderë¥¼ ë°˜í™˜
<!-- ... ê¸°ì¡´ ë‚´ìš© ... -->
---

## ë°œí‘œ êµ¬ì„± íŒ
<!-- ... existing content ... -->

| í•­ëª©                 | ì‹œê°ì  ìë£Œ ì¶”ì²œ                                       |
| -------------------- | ------------------------------------------------------ |
| ê·¸ë˜í”„ í‘œí˜„          | ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ë„ì‹ (í‘œ í˜•íƒœ)                             |
| ìœ„ìƒ ì •ë ¬ (DFS vs Kahn) | DAG ì˜ˆì‹œ + ì •ì  ìˆœì„œ ë³€í™” ë¹„êµ                         |
| ìµœë‹¨ ê²½ë¡œ (BFS)      | BFS ë™ì‘ íë¦„ ì‹œê°í™” (í ìƒíƒœ, ê±°ë¦¬ ë°°ì—´ ì—…ë°ì´íŠ¸ ê³¼ì •) |
| ìµœë‹¨ ê²½ë¡œ (Dijkstra) | ìš°ì„ ìˆœìœ„ í ìƒíƒœ ë³€í™” ë° ê±°ë¦¬ ë°°ì—´ ì—…ë°ì´íŠ¸ ê³¼ì • ì‹œê°í™” |

---

ì´ ìë£ŒëŠ” ì„¸ë¯¸ë‚˜ ë°œí‘œì— í™œìš©í•  ìˆ˜ ìˆë„ë¡ ì½”ë“œ ì¤‘ì‹¬ìœ¼ë¡œ êµ¬ì„±ë˜ì–´ ìˆìœ¼ë©°, ê° ì•Œê³ ë¦¬ì¦˜ì˜ í•µì‹¬ íë¦„ê³¼ ë°œí‘œ í¬ì¸íŠ¸ë¥¼ í¬í•¨í•˜ê³  ìˆìŠµë‹ˆë‹¤.


