

## 1. 무방향 그래프 응용 (9.6.1)

**정의**: 무방향 그래프에서 깊이 우선 탐색(DFS)을 수행하면, 그래프가 연결되어 있는지를 확인할 수 있으며, 연결 요소(connected components)를 분리해낼 수 있습니다.

**DFS의 작동 방식**:
- 한 정점에서 시작하여 가능한 한 깊게 탐색하고,
- 더 이상 갈 수 없을 경우 직전 정점으로 돌아가 다른 경로를 탐색합니다.
- 이 과정을 통해 하나의 DFS 트리(DSP Tree)가 만들어집니다.

**DFS Forest**:
- 그래프가 연결되어 있지 않다면, 모든 정점을 방문하기 위해 DFS를 여러 번 수행해야 합니다.
- 이 경우 각각의 DFS 수행은 하나의 연결 요소를 탐색하게 되며, 전체 탐색 결과는 여러 개의 DFS Tree로 구성된 DFS Forest입니다.

**실생활 비유**:
- 무인도로 구성된 군도에서, 각 섬 안의 마을들만 도로로 연결되어 있다면, 섬 하나가 연결 요소입니다.
- 각각의 섬을 DFS로 탐색해 보면, 전체 군도를 DFS Forest로 표현할 수 있습니다.

**시각적 예시**:
```
    A — B    E — F
    |        |
    C — D    G
```
- 연결 요소 1: {A, B, C, D}
- 연결 요소 2: {E, F, G}

---

## 2. 이중 연결성 (Biconnectivity, 9.6.2)

**정의**: 무방향 그래프에서 어떤 정점을 제거해도 그래프가 분리되지 않는 경우, 그 그래프는 이중 연결(biconnected)되어 있다고 합니다.

**단절점(Articulation Point)**:
- 하나의 정점을 제거했을 때 그래프가 둘 이상의 부분으로 나뉘게 된다면, 그 정점은 단절점입니다.

**DFS 기반 탐색 알고리즘**:
- DFS를 통해 각 정점에 두 개의 값을 기록합니다:
  - Num(v): 정점이 DFS에서 처음 방문된 순서를 기록
  - Low(v): v 또는 v의 자손 중 가장 먼저 방문된 정점의 Num 값
- 자식 정점 w가 있고 Low(w) ≥ Num(v) 라면, v는 단절점입니다.

**루트 정점 예외 처리**:
- DFS 트리의 루트가 두 개 이상의 자식을 가지면 루트 자체도 단절점이 됩니다.

**실생활 비유**:
- 도시 간 도로망에서, 특정 도시가 유일한 연결 지점이라면 그 도시는 단절점입니다.

**시각적 예시**:
```
    A — B — C
         |
         D — E
```
- B는 단절점 (B를 제거하면 A와 나머지 정점이 연결되지 않음)

---

## 3. 오일러 회로 (Euler Circuit, 9.6.3)

**정의**: 그래프 내의 모든 간선을 정확히 한 번씩만 지나고, 출발한 정점으로 돌아오는 경로를 오일러 회로라고 합니다.

**조건**:
- 그래프는 연결되어 있어야 합니다.
- 모든 정점의 차수가 짝수여야 합니다.

**오일러 경로(Euler Path)**:
- 오일러 경로는 출발점과 도착점이 다를 수 있으며, 간선을 한 번씩만 지나면 됩니다.
- 이 경우 홀수 차수를 가진 정점이 정확히 2개 있어야 합니다.

**오일러 vs 해밀턴 회로 비교**

| 항목 | 오일러 회로 | 해밀턴 회로 |
|------|--------------|----------------|
| 기준 | 모든 간선 1회씩 사용 | 모든 정점 1회씩 방문 |
| 조건 | 모든 정점 차수 짝수 | NP-문제, 일반 조건 없음 |
| 경로 길이 | 간선 수 | 정점 수 |
| 실생활 예 | 도로 점검, 전선 검사 | 여행 경로 최적화, 우편 배달 경로 |

**예시**:
```
A — B
|   |
D — C
```
- 오일러 회로 경로: A-B-C-D-A

---

## 4. 방향 그래프의 간선 분류 (9.6.4)

**정의**: 방향 그래프에서 DFS를 수행하면 발생하는 간선들을 유형에 따라 분류할 수 있습니다. 이 분류는 사이클 여부, 위상 정렬 가능성, 모듈 의존성 분석 등에 유용하게 사용됩니다.

**간선의 종류**:

| 유형 | 정의 |
|------|------|
| Tree Edge | DFS 탐색 중 처음 방문한 정점으로 향하는 간선 |
| Back Edge | 현재 정점의 조상으로 향하는 간선 (사이클 존재) |
| Forward Edge | 이미 방문된 후손으로 향하는 간선 |
| Cross Edge | 다른 DFS 트리(형제 또는 이전 서브트리)의 정점으로 향하는 간선 |

**사이클 판별**:
- DFS 도중 Back Edge가 발견되면 그래프에 사이클이 존재합니다.
- Back Edge가 없으면 해당 방향 그래프는 DAG(유향 비순환 그래프)입니다.

**실생활 비유**:
- 작업 스케줄 그래프에서 순환 의존성(Back Edge)이 발견되면 스케줄링이 불가능함

**예시 조건 분류**:

- `v`가 처음 방문: Tree Edge  
- `v`는 아직 종료되지 않음: Back Edge  
- `v`가 종료됐고 Num[u] < Num[v]: Forward Edge  
- `v`가 종료됐고 Num[u] > Num[v]: Cross Edge

---

## 5. 강한 연결 요소 (Strongly Connected Components, 9.6.5)

**정의**: 방향 그래프에서 정점 쌍 (u, v)에 대해 u→v, v→u 경로가 모두 존재한다면, u와 v는 같은 강한 연결 요소(SCC)에 속합니다.

**Kosaraju 알고리즘 단계**:

1. **원래 그래프 G에서 DFS 수행**  
   → 각 정점의 post-order 번호 기록
2. **G의 모든 간선 방향을 반전**  
   → 역방향 그래프 Gr 생성
3. **Gr에서 post-order 역순으로 DFS 수행**  
   → 각 DFS 호출이 하나의 SCC를 형성

**예시 결과**:
- 정점 집합: {G}, {H, I, J}, {B, A, C, F}, {D}, {E}
- 이들은 각각 독립적인 SCC이며, 전체 그래프는 SCC들로 구성된 DAG처럼 표현될 수 있습니다.

**시간 복잡도**: O(V + E)

**실생활 비유**:
- 일방통행 도로로 연결된 도시들 중, 상호 왕복 가능한 도시 묶음이 하나의 SCC입니다.

---

이상으로 DFS를 활용한 그래프의 주요 응용 기법들을 정리하였습니다.

[[7. NP-Complete Problems]]