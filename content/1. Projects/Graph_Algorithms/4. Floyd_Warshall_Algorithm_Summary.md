# 플로이드-워셜 (Floyd–Warshall) 알고리즘 정리

플로이드-워셜 알고리즘은 그래프에서 모든 정점 쌍 간의 최단 경로를 찾는 알고리즘입니다.

## 1. 문제 정의

*   **목표**: 그래프 내의 모든 정점 쌍 \((i, j)\) 간의 최단 거리를 계산합니다.
*   **입력**:
    *   정점 집합 \(V = \{1, 2, \dots, n\}\).
    *   간선 가중치 \(w(u, v)\): 각 간선 \((u, v)\)의 비용 또는 거리. 음수 가중치를 허용하지만, 음수 가중치로 인한 **사이클(음수 사이클)**은 없어야 합니다.
*   **출력**:
    *   2차원 배열 `dist[i][j]`: 정점 \(i\)에서 정점 \(j\)까지의 최단 거리. 경로가 없으면 무한대(∞)로 표시됩니다.

## 2. 핵심 아이디어

1.  **경유지 확장**: 1번부터 \(n\)번까지의 정점을 순서대로 '경유지' \(k\)로 고려합니다. 즉, "정점 \(k\)를 거쳐가는 것이 더 빠를까?"를 모든 \(k\)에 대해 검사합니다.
2.  **3중 반복 비교 및 갱신**: 현재 알려진 \(i \rightarrow j\)의 최단 거리(`dist[i][j]`)와 \(i \rightarrow k \rightarrow j\) 경로의 거리(`dist[i][k] + dist[k][j]`)를 비교하여 더 짧은 값으로 `dist[i][j]`를 갱신합니다.
    ```
    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    ```
3.  **동적 프로그래밍**: \(k\)번째 정점까지를 경유지로 고려했을 때의 최단 거리 정보를 사용하여, \(k+1\)번째 정점을 경유지로 추가했을 때의 최단 거리를 계산합니다. 이전 단계의 결과가 다음 단계 계산에 재사용됩니다.
## 3. 의사코드 (Pseudocode)

```pseudo
// 함수 정의: 플로이드-워셜 알고리즘
function FloydWarshall(graph):
  n = 수(graph.vertices) // 정점의 개수
  dist = n x n 크기의 2차원 배열 초기화 (모든 값을 ∞로)

  // 1단계: 초기화
  // 자기 자신으로 가는 거리는 0
  // 직접 연결된 간선의 가중치로 초기화
  for i from 1 to n:
    dist[i][i] = 0
  for each edge (u, v) with weight w in graph:
    dist[u][v] = w

  // 2단계: 경유지 k를 이용한 거리 갱신
  for k from 1 to n:      // 경유할 정점 k
    for i from 1 to n:    // 출발 정점 i
      for j from 1 to n:  // 도착 정점 j
        // i에서 k를 거쳐 j로 가는 거리가 현재 dist[i][j]보다 짧으면 갱신
        if dist[i][k] != ∞ and dist[k][j] != ∞: // 경로가 존재할 때만
          potential_dist = dist[i][k] + dist[k][j]
          if potential_dist < dist[i][j]:
            dist[i][j] = potential_dist

  // 음수 사이클 검사 (선택 사항)
  for i from 1 to n:
    if dist[i][i] < 0:
      print("음수 사이클이 존재합니다.")
      return // 또는 적절한 오류 처리

  return dist // 최종 최단 거리 배열 반환
```
## 4. 복잡도 및 음수 사이클 감지
| 항목          | 값                | 설명                                        |
| ------------- | ----------------- | ------------------------------------------- |
| 시간 복잡도   | \(O(n^3)\)        | 3중 반복문(k, i, j) 때문입니다.             |
| 공간 복잡도   | \(O(n^2)\)        | 최단 거리를 저장할 2차원 배열 `dist` 필요. |
| 음수 사이클 감지 | 알고리즘 종료 후 | `dist[v][v] < 0`인 정점 `v`가 있다면 음수 사이클 존재. |

## 5. 동작 예시

### 입력 그래프
*   정점: A, B, C
*   간선 및 가중치: A→B (3), B→C (−2), A→C (4)
### 초기 `dist` 배열

|       | A | B | C  |
| :---- | :-: | :-: | :-: |
| **A** | 0 | 3 | 4  |
| **B** | ∞ | 0 | −2 |
| **C** | ∞ | ∞ | 0  |

### 단계별 갱신 (k 기준)

*   **k = A (1)**: `dist` 배열 변화 없음. (A를 경유해도 더 짧아지는 경로 없음)
*   **k = B (2)**:
    *   `dist[A][C]` 갱신 확인: `dist[A][B] + dist[B][C] = 3 + (-2) = 1`.
    *   기존 `dist[A][C]`는 4였으므로, 1로 갱신. `dist[A][C] = 1`.
*   **k = C (3)**: `dist` 배열 변화 없음.

### 최종 `dist` 배열

|       | A | B | C  |
| :---- | :-: | :-: | :-: |
| **A** | 0 | 3 | 1  |
| **B** | ∞ | 0 | −2 |
| **C** | ∞ | ∞ | 0  |

최종적으로 A에서 C까지의 최단 거리는 1 (경로 A→B→C)로 결정됩니다.
## 6. 장점 및 단점
| 장점                                                 | 단점                                                        |
| :--------------------------------------------------- | :---------------------------------------------------------- |
| 구현이 간단함 (3중 반복문 구조).                     | 정점 수(\(n\))가 많을 경우 \(O(n^3)\) 시간 복잡도가 부담될 수 있음. |
| 음수 가중치 간선을 처리할 수 있음 (음수 사이클 제외).  | \(O(n^2)\)의 공간 복잡도 필요.                                |
| 한 번의 실행으로 모든 정점 쌍 간의 최단 거리를 구함. | 간선 수가 적은 희소 그래프(Sparse graph)에서는 비효율적일 수 있음. |
| 다양한 문제(라우팅 테이블, 비용 행렬 계산 등)에 유용함. | (희소 그래프의 경우) 다익스트라를 각 정점에서 반복 실행하는 것이 더 빠를 수 있음. |
## 7. 주요 응용 분야
| 분야            | 활용 예시                                                              |
| :-------------- | :--------------------------------------------------------------------- |
| **네트워크 라우팅** | 모든 라우터 쌍 간의 최단 경로(지연 시간, 비용 등) 테이블 생성.           |
| **물류 및 운송**  | 모든 창고/지점 간 최단 운송 거리 또는 비용 행렬 계산 → 효율적 배송 계획. |
| **게임 개발 (AI)** | 게임 맵 내 모든 지역 쌍 간 최단 이동 시간/비용 사전 계산 → 실시간 경로 탐색 부담 감소. |
| **생물정보학**    | 분자 구조 내 원자 쌍 간의 거리(결합 수 등) 행렬 계산.                 |
| **교통 시스템**   | 도시 내 모든 교차로 쌍 간의 최단 주행 시간 계산.                       |

## 8. 요약

플로이드-워셜 알고리즘은 **모든 정점 쌍 간의 최단 경로**를 찾는 데 효과적인 방법입니다. **경유지를 하나씩 추가**하며 **3중 반복**을 통해 거리 행렬을 점진적으로 **갱신**하는 **동적 프로그래밍** 기법을 사용합니다. 음수 가중치를 처리할 수 있으며 음수 사이클도 감지할 수 있습니다. 구현이 간단하고 모든 쌍의 결과를 한 번에 얻을 수 있어, 그래프가 너무 크지 않거나 밀집된 경우 유용하게 사용됩니다.