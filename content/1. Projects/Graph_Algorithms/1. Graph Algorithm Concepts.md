# 그래프 기본 개념 (TASK 1)

## 1. 그래프의 정의와 기본 용어

그래프 G는 두 가지 요소로 구성됩니다: G = (V, E)
- V = 정점(vertices)의 집합
- E = 간선(edges)의 집합, 각 간선은 정점 쌍 (v, w)로 표현됩니다.

### 1.1 그래프의 주요 유형

#### 방향성에 따른 분류

**무방향 그래프(Undirected Graph)**:
- 간선에 방향이 없습니다.
- 간선 (v, w)와 (w, v)는 동일합니다.
- 예: 도로망, 전기 회로, 친구 관계

**방향 그래프(Directed Graph 또는 Digraph)**:
- 간선에 방향이 있습니다.
- 간선 (v, w)는 v에서 w로 가는 화살표로 표시됩니다.
- 예: 웹 페이지 링크, 작업 의존성, 일방 통행 도로

#### 가중치에 따른 분류

**비가중치 그래프(Unweighted Graph)**:
- 모든 간선의 중요도가 동일합니다.

**가중치 그래프(Weighted Graph)**:
- 각 간선에 비용이나 가중치가 할당됩니다.
- 예: 도시 간 거리, 네트워크 대역폭

### 1.2 기본 용어

**인접(Adjacent)**: 두 정점이 간선으로 직접 연결되어 있을 때, 서로 인접해 있다고 말합니다.

**경로(Path)**: 정점의 연속된 나열(v₁, v₂, ..., vₙ)으로, 각 연속된 쌍 (vᵢ, vᵢ₊₁)이 간선으로 연결되어 있습니다.
- 경로의 길이는 포함된 간선의 수입니다.
- 가중치 그래프에서는 포함된 간선의 가중치 합을 경로의 비용이라고 합니다.

**단순 경로(Simple Path)**: 모든 정점(시작과 끝 제외)이 한 번만 나타나는 경로입니다.

**사이클(Cycle)**: 시작 정점과 끝 정점이 동일한 경로입니다.
- 단순 사이클은 시작/끝 정점을 제외한 모든 정점이 한 번만 나타나는 사이클입니다.

#### 시각적 이해

아래는 그래프 기본 개념에 대한 시각적 표현입니다:

1. **인접 정점**: A와 C가 직접 간선으로 연결되어 있습니다.
2. **경로**: A→B→C→D와 같이 연속해서 간선으로 연결된 정점들의 나열입니다.
3. **단순 경로**: A→B→C→D→E와 같이 모든 정점을 한 번만 방문하는 경로입니다.
4. **사이클**: A→B→C→D→A와 같이 시작 정점으로 돌아오는 경로입니다.
5. **단순 사이클**: A→B→C→D→E→F→A와 같이 시작/끝 정점을 제외하고 모든 정점을 한 번만 방문하는 사이클입니다.

## 2. 연결성 관련 용어

### 2.1 연결 그래프(Connected Graph)

**정의**: 모든 정점 쌍 사이에 경로가 존재하는 무방향 그래프입니다.

**실생활 비유**: 마을의 도로 네트워크를 생각해보세요. 만약 마을의 모든 집 사이에 어떤 경로로든 이동할 수 있다면, 이 마을은 "연결된" 마을입니다.

```
    A --- B
    |     |
    |     |
    C --- D --- E
```
이 그래프에서는 어떤 정점에서 출발하든 다른 모든 정점에 도달할 수 있습니다.

### 2.2 강한 연결 그래프(Strongly Connected Graph)

**정의**: 방향 그래프에서 모든 정점 쌍 (v, w) 사이에 v→w 경로와 w→v 경로가 모두 존재하는 그래프입니다.

**실생활 비유**: 일방통행길이 있는 도시에서, 어떤 건물에서도 다른 모든 건물로 갈 수 있고, 다시 원래 건물로 돌아올 수도 있습니다.

```
    A ──→ B
    ↑     |
    |     ↓
    D ←── C
```
이 방향 그래프에서 어디서든 시작해서 다른 모든 점에 도달할 수 있습니다.

### 2.3 약한 연결 그래프(Weakly Connected Graph)

**정의**: 방향 그래프에서 모든 간선의 방향을 무시했을 때 연결 그래프가 되는 그래프입니다.

**실생활 비유**: SNS에서 '팔로우' 관계를 생각해보세요. A가 B를 팔로우하고, B가 C를 팔로우하지만, C는 아무도 팔로우하지 않습니다. 방향을 무시하면 A-B-C가 모두 연결되어 있지만, 방향을 고려하면 C에서 다른 정점으로 가는 경로는 없습니다.

```
    A ──→ B ──→ C
```
방향을 따르면 A→B→C로만 이동 가능하지만, 방향을 무시하면 A-B-C 모두 연결됩니다.

### 2.4 연결 요소(Connected Component)

**정의**: 그래프의 최대 연결 부분 그래프입니다.

**실생활 비유**: 여러 개의 섬으로 이루어진 군도를 생각해보세요. 각 섬 내에서는 모든 지역을 방문할 수 있지만, 다른 섬으로는 이동할 수 없습니다. 각각의 섬이 하나의 '연결 요소'입니다.

```
    A --- B     E --- F
    |           |     |
    C --- D     G --- H
```
이 그래프에는 두 개의 연결 요소가 있습니다: {A,B,C,D}와 {E,F,G,H}

## 3. 특수 그래프 유형

**완전 그래프(Complete Graph)**: 모든 정점 쌍이 간선으로 연결된 그래프입니다. n개의 정점이 있는 완전 그래프는 n(n-1)/2개의 간선을 가집니다.

**트리(Tree)**: 사이클이 없는 연결 그래프입니다. n개의 정점을 가진 트리는 정확히 n-1개의 간선을 가집니다.

**이분 그래프(Bipartite Graph)**: 정점 집합을 두 개의 독립된 부분으로 나눌 수 있어, 모든 간선이 서로 다른 부분에 있는 정점을 연결하는 그래프입니다.

## 4. 그래프 표현 방법

### 4.1 인접 행렬(Adjacency Matrix)

인접 행렬은 |V| × |V| 크기의 2차원 배열입니다.

**작동 방식**:
- 무방향 그래프: matrix[i][j] = matrix[j][i] = 1 (또는 가중치)
- 방향 그래프: matrix[i][j] = 1 (i에서 j로 가는 간선이 있을 때)
- 가중치 그래프: matrix[i][j] = 간선의 가중치

**C++ 코드 예시**:
```cpp
class GraphMatrix {
private:
    int V;  // 정점의 수
    std::vector<std::vector<int>> matrix;  // 인접 행렬

public:
    // 생성자: V개의 정점을 가진 그래프 초기화
    GraphMatrix(int vertices) : V(vertices) {
        // 모든 원소가 0인 V x V 행렬 생성
        matrix.resize(V, std::vector<int>(V, 0));
    }

    // 무방향 그래프에 간선 추가
    void addEdge(int v, int w, int weight = 1) {
        if (v >= 0 && v < V && w >= 0 && w < V) {
            matrix[v][w] = weight;  // v에서 w로 가는 간선
            matrix[w][v] = weight;  // w에서 v로 가는 간선 (무방향)
        }
    }

    // 방향 그래프에 간선 추가
    void addDirectedEdge(int v, int w, int weight = 1) {
        if (v >= 0 && v < V && w >= 0 && w < V) {
            matrix[v][w] = weight;  // v에서 w로 가는 간선만 추가
        }
    }

    // 간선의 존재 여부 확인
    bool isEdge(int v, int w) {
        if (v >= 0 && v < V && w >= 0 && w < V) {
            return matrix[v][w] != 0;
        }
        return false;
    }
};
```

**시각적 예시**: Figure 9.2와 같은 7개 정점 그래프의 인접 행렬 표현

### 4.2 인접 리스트(Adjacency List)

인접 리스트는 각 정점에 대해 인접한 정점들의 리스트를 유지합니다.

**작동 방식**:
- 각 정점 v에 대해, adjList[v]는 v에 인접한 모든 정점(과 가중치)의 리스트입니다.
- 무방향 그래프에서는 간선 (v, w)가 v의 리스트와 w의 리스트 모두에 나타납니다.

**C++ 코드 예시**:
```cpp
class GraphList {
private:
    int V;  // 정점의 수
    std::vector<std::list<std::pair<int, int>>> adj;  // 인접 리스트 (정점, 가중치)

public:
    // 생성자: V개의 정점을 가진 그래프 초기화
    GraphList(int vertices) : V(vertices) {
        adj.resize(V);
    }

    // 무방향 그래프에 간선 추가
    void addEdge(int v, int w, int weight = 1) {
        if (v >= 0 && v < V && w >= 0 && w < V) {
            adj[v].push_back({w, weight});  // v에 w 추가
            adj[w].push_back({v, weight});  // w에 v 추가 (무방향)
        }
    }

    // 방향 그래프에 간선 추가
    void addDirectedEdge(int v, int w, int weight = 1) {
        if (v >= 0 && v < V && w >= 0 && w < V) {
            adj[v].push_back({w, weight});  // v에 w만 추가
        }
    }
};
```

**실제 예시**: Figure 9.2에서 보여준 인접 리스트 표현은 다음과 같은 그래프를 나타냅니다:
- 정점 1은 정점 2, 4, 3과 연결됨
- 정점 2는 정점 4, 5와 연결됨
- 정점 3은 정점 6과 연결됨
- 정점 4는 정점 6, 7, 3과 연결됨
- 정점 5는 정점 4, 7과 연결됨
- 정점 6은 어떤 정점과도 연결되지 않음
- 정점 7은 정점 6과 연결됨

## 5. 희소 그래프 vs 밀집 그래프

### 5.1 희소 그래프(Sparse Graph)

**정의**: 간선 수(E)가 정점 수(V)의 제곱보다 훨씬 적은 그래프 (E << V²)

**특징**:
- 실제 세계의 많은 그래프(소셜 네트워크, 도로망, 웹 그래프 등)
- 인접 리스트로 표현하는 것이 효율적
- 대부분의 행렬 셀이 0(연결 없음)이므로 인접 행렬은 공간 낭비가 큼

### 5.2 밀집 그래프(Dense Graph)

**정의**: 간선 수(E)가 정점 수(V)의 제곱에 가까운 그래프 (E ≈ V²)

**특징**:
- 완전 그래프나 그에 가까운 그래프
- 인접 행렬로 표현하는 것이 효율적
- 대부분의 행렬 셀이 채워져 있으므로 인접 행렬이 공간 효율적

## 6. 표현 방법의 비교

### 6.1 시간 복잡도 비교

| 연산 | 인접 행렬 | 인접 리스트 |
|------|-----------|-------------|
| 간선 추가 | O(1) | O(1) |
| 간선 제거 | O(1) | O(degree(v)) |
| 간선 존재 확인 | O(1) | O(degree(v)) |
| 모든 인접 정점 탐색 | O(V) | O(degree(v)) |
| 모든 간선 순회 | O(V²) | O(V + E) |

### 6.2 공간 복잡도 비교

- 인접 행렬: O(V²) - 정점 수의 제곱에 비례하는 공간 필요
- 인접 리스트: O(V + E) - 정점 수 + 간선 수에 비례하는 공간 필요

### 6.3 표현 방법 선택 기준

**간단한 결정 가이드**:
- 그래프의 정점 수가 적거나(100개 이하), 간선이 매우 많은 밀집 그래프라면 → **인접 행렬**
- 정점 수가 많고(1000개 이상), 간선이 상대적으로 적은 희소 그래프라면 → **인접 리스트**
- 정점 간 연결 여부를 자주 확인해야 한다면 → **인접 행렬**
- 정점의 모든 이웃을 자주 확인해야 한다면 → **인접 리스트**

## 7. 대규모 그래프의 메모리 관리

대규모 그래프를 다룰 때의 메모리 관리 이슈:

1. **동적 메모리 할당**: 매우 큰 그래프의 경우, 동적으로 필요한 메모리만 할당하는 것이 중요합니다.

2. **압축 표현**: 특수한 경우, 비트 행렬이나 압축된 희소 행렬과 같은 효율적인 표현 방법을 사용할 수 있습니다.

3. **외부 저장소 활용**: 메모리에 맞지 않는 매우 큰 그래프의 경우, 디스크 기반 그래프 처리 알고리즘을 고려해야 합니다.

4. **그래프 분할**: 대규모 그래프를 더 작은 부분으로 나누어 처리하는 방법을 고려할 수 있습니다.

---

이상으로 그래프의 기본 개념과 표현 방법에 대한 내용을 정리했습니다. 이러한 기초 개념은 앞으로 배울 그래프 순회 알고리즘(DFS, BFS)과 최단 경로 알고리즘 등의 기반이 됩니다.