## Verilog 시뮬레이터를 마음대로 조정하는 VPI
[[PLI]]가 Verilog와 외부 언어를 잇는 다리였다면, **VPI(Verilog Procedural Interface)** 는 단 한 단계 더 발전한 인터페이스입니다. VPI는 Verilog 표준에 포함된 공식 API로서 PLI 2.0이라고도 불립니다. 이를 이용하면 C/C++로 작성한 프로그램이 Verilog 시뮬레이션의 내부를 들여다보고 조작할 수 있습니다. 예를 들어, C 코드에서 Verilog 신호들을 탐색하여 값을 읽거나 바꾸는 일이 가능하고, 시뮬레이션 시간의 흐름에 맞춰 특정 이벤트에 콜백 함수를 실행하게 할 수 있습니다. 또한 사용자가 새로운 시스템 함수를 정의하고 그 동작을 C로 구현한 뒤, Verilog에서 `$my_func`와 같이 호출하는 것도 VPI로 가능한 작업입니다.

**언제 VPI를 활용할까?** Verilog만으로 하기 어려운 복잡한 검증 로직이나 시뮬레이터 제어가 필요할 때 VPI가 빛을 발한다. 예를 들어, 설계의 수많은 신호를 자동으로 검증해야 한다면, VPI를 쓰면 C 코드로 모든 신호의 변화를 감시하고 로그를 남기거나, 특정 조건에서만 동작하는 검증 코드를 삽입할 수 있다. Verilog 코드로는 힘든 작업도 VPI를 활용하면 마치 시뮬레이터에 **플러그인**을 끼워넣은 것처럼 원하는 기능을 추가할 수 있습니다.

- **디자인 구조 탐색**:
  C 프로그램이 Verilog 설계의 모듈/신호 구조를 훑어보며 필요한 정보를 수집.
- **이벤트 기반 동작**:
  특정 신호 변화나 시간 등의 이벤트에 맞춰 C로 작성된 콜백 실행
- **특수 기능 확장**:
  파형 뷰어나 커버리지 수집 등 시뮬레이터에 사용자 정의 기능 부가

이렇듯 VPI는 매우 강력하지만 배우고 쓰기가 쉽진 않습니다. 대신 요즘에는 단순히 외부 함수를 호출하는 정도라면 더 간편한 [[DPI]]를 많이 활용합니다. 실제로 업계에서는 "가능한 일은 DPI로하고, 안되는 일은 VPI로 한다. 가능하면 두 가지 모두 배우는 것이 좋지만, DPI를 더 자주 사용하게 될 것이므로 DPI에 더 중점을 두는 것이 좋다."는 말까지 있을 정도입니다. VPI는 DPI로 처리하기 힘든 고급 작업에만 주로 쓰이며, 완전히 대체될 수 없는 전문 영역을 맡고 있습니다.

## VPI(Verilog Procedural Interface)
### 개요
[[Verilog]]는 RTL 설계 언어로 폭넓게 사용됩니다. 특히 정확한 타이밍 동작 모델링과 Gate-level 시뮬레이션에서는 업계 표준이라 할 수 있습니다. 하지만 Verilog 만으로는 다음과 같은 한계가 여전히 존재합니다.
- 추상적인 System-level 동작 표현이 어렵다.
- 복잡한 transaction을 다루기엔 구조가 제한적이다.
- Random stimulus 생성 및 protocol-level 시뮬레이션에 적합하지 않다.
그래서 지금의 검증 방식은

| 분야                        | 사용 언어/기술                                  |
| ------------------------- | ----------------------------------------- |
| **RTL 설계**                | Verilog, SystemVerilog                    |
| **검증 환경 (Testbench)**     | SystemVerilog + UVM / Python + cocotb     |
| **System-Level Modeling** | SystemC (제한적 사용, 일부 SoC 모델링에 적용), TLM 2.0 |
| **외부 연동/디버깅/툴 통합**        | VPI / DPI (SystemVerilog용)                |

>[!definition]
>Verilog 시뮬레이터와 외부 C 코드 간의 인터페이스를 제공하는 표준. 

VPI를 사용하면 외부 C 코드에서 시뮬레이터 내부의 Verilog 객체(예: signal, module, time 등)에 접근하고 제어할 수 있습니다. 이것은 testbench 작성, 디버깅, 시뮬레이션 분석, 파형 추출 등 다양한 목적으로 활용됩니다.

>[!reflection]
>쉽게 말해, Verilog 시뮬레이터 내부 동작을 외부 C 코드로 관찰하거나 조작할 수 있는 공식적인 통로

### 동작 구조
|구성요소|역할|
|---|---|
|`vpiHandle`|Verilog 객체(모듈, 시그널 등)를 참조하는 핸들|
|`s_vpi_value`|값을 읽거나 쓸 때 사용하는 구조체|
|`vpi_register_cb`|시뮬레이션 이벤트에 콜백을 등록하는 함수|

### Usage
|용도|쓰는 이유|
|---|---|
|신호 값 실시간 추적|Waveform이 부족한 경우|
|디버깅 툴 개발|시뮬레이터 내부에 직접 접근 가능|
|외부 시스템 연동|TCP/파일 등으로 C 프로그램과 연결|
|자동 검증 시스템 통합|시뮬레이션 자동화, 로그 수집 등|

VPI는 특히 복잡한 설계 검증에 효과적이며, 다양한 테스트 시나리오를 구현하는 데 강력한 도구입니다. 또한 VPI와 [[DPI|DPI(Direct Programming Interface)]]는 서로 다른 접근 방식을 제공하므로, 요구 사항에 따라 적절한 방법을 선택해야 합니다.